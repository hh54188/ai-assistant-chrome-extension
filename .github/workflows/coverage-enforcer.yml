name: Store Coverage Enforcer

on:
  workflow_dispatch:
    inputs:
      run-id:
        description: 'Workflow run ID to download coverage artifacts from'
        default: '18072644387'
        required: true
        type: string
  workflow_run:
    workflows: [CI Pipeline]
    types: [completed]

permissions:
  contents: write      # Push branches, create commits
  pull-requests: write # Create and manage PRs
  actions: write       # Trigger workflows
  checks: write        # Create/update check runs
  issues: write        # Create issues for tracking

jobs:
  check-coverage:
    if: >-
      ${{ github.event_name == 'workflow_dispatch' || 
          (github.event.workflow_run.conclusion == 'success' && 
           github.event.workflow_run.name == 'CI Pipeline') }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure git identity
      run: |
        git config user.name "Coverage Bot"
        git config user.email "coverage-bot@github.com"

    - name: Verify Workflow Run ID
      run: |
        # Determine the workflow run ID based on trigger type
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          RUN_ID="${{ github.event.inputs.run-id }}"
          echo "‚úÖ Manual trigger - Using provided run ID: $RUN_ID"
        elif [ "${{ github.event_name }}" = "workflow_run" ]; then
          RUN_ID="${{ github.event.workflow_run.id }}"
          echo "‚úÖ Automatic trigger - Using workflow run ID: $RUN_ID"
        else
          echo "‚ùå Unsupported trigger type: ${{ github.event_name }}"
          exit 1
        fi
        
        # Additional fallback logic for workflow_dispatch
        if [ -z "$RUN_ID" ] && [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Try alternative input names
          RUN_ID="${{ github.event.inputs.run_id || github.event.inputs.runId || github.event.inputs.run-id }}"
          echo "üîÑ Trying alternative input names: $RUN_ID"
        fi
        
        if [ -z "$RUN_ID" ]; then
          echo "‚ùå Workflow run ID is missing"
          echo "Event name: ${{ github.event_name }}"
          echo "Available inputs: ${{ toJSON(github.event.inputs) }}"
          exit 1
        fi
        
        echo "RUN_ID=$RUN_ID" >> $GITHUB_ENV
        echo "‚úÖ Workflow run ID set: $RUN_ID"
        
        # Verify environment variables are set correctly
        echo "üîç Environment variables verification:"
        echo "  - RUN_ID env var: '$RUN_ID'"

    - name: Download Coverage Artifacts
      uses: actions/download-artifact@v5
      with:
        name: stores-coverage-report
        path: ./coverage/
        run-id: ${{ env.RUN_ID }}
        repository: ${{ github.repository }}
        github-token: ${{ secrets.GITHUB_TOKEN }}

    - name: Verify Coverage Artifact
      run: |
        echo "üîç Verifying downloaded coverage artifact..."
        echo "=========================================="
        
        # Check if coverage directory exists
        if [ ! -d "./coverage" ]; then
          echo "‚ùå Coverage directory not found: ./coverage/"
          echo "This indicates the artifact download failed."
          echo "Please check the previous step for download errors."
          exit 1
        fi
        
        echo "‚úÖ Coverage directory found: ./coverage/"
        
        # List contents of coverage directory
        echo "üìÅ Contents of coverage directory:"
        ls -la ./coverage/
        
        # Check for expected files
        EXPECTED_FILES=(
          "lcov-report/index.html"
          "lcov.info"
          "coverage-final.json"
        )
        
        MISSING_FILES=()
        for file in "${EXPECTED_FILES[@]}"; do
          if [ ! -f "./coverage/$file" ]; then
            MISSING_FILES+=("$file")
          else
            echo "‚úÖ Found: $file"
          fi
        done
        
        # Check if any critical files are missing
        if [ ${#MISSING_FILES[@]} -gt 0 ]; then
          echo "‚ö†Ô∏è  Some expected files are missing:"
          for file in "${MISSING_FILES[@]}"; do
            echo "  - $file"
          done
          
          # Check if we have at least the HTML report
          if [ ! -f "./coverage/lcov-report/index.html" ]; then
            echo "‚ùå Critical file missing: lcov-report/index.html"
            echo "This file is required for coverage analysis."
            exit 1
          fi
        fi
        
        # Check file sizes to ensure they're not empty
        echo "üìä File sizes:"
        find ./coverage -type f -exec ls -lh {} \; | head -10
        
        echo "‚úÖ Coverage artifact verification completed successfully"
        echo "=========================================="

    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: chrome-extension/package-lock.json

    - name: Install Chrome Extension dependencies
      working-directory: ./chrome-extension
      run: npm ci

    - name: Install Coverage Analysis Tools
      run: |
        npm install -g @vitest/coverage-v8
        npm install -g nyc

    - name: Analyze Coverage Data
      id: coverage-analysis
      working-directory: ./chrome-extension
      run: |
        echo "Analyzing coverage data from artifact..."
        
        # Verify coverage data exists (should already be verified in previous step)
        if [ ! -d "../coverage" ] || [ ! -f "../coverage/lcov-report/index.html" ]; then
          echo "‚ùå Coverage data is missing - this should not happen after verification step"
          echo "coverage_available=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Parse coverage summary from lcov.info if available
        if [ -f "../coverage/lcov.info" ]; then
          echo "Parsing lcov.info..."
          
          # Extract raw coverage counts from lcov.info (sum across all records)
          # Use a simple approach that works reliably in GitHub Actions
          LINES_FOUND=0
          LINES_HIT=0
          FUNCTIONS_FOUND=0
          FUNCTIONS_HIT=0
          BRANCHES_FOUND=0
          BRANCHES_HIT=0
          
          # Sum up all coverage data
          while IFS= read -r line; do
            if [[ $line =~ ^LF:([0-9]+) ]]; then
              LINES_FOUND=$((LINES_FOUND + ${BASH_REMATCH[1]}))
            elif [[ $line =~ ^LH:([0-9]+) ]]; then
              LINES_HIT=$((LINES_HIT + ${BASH_REMATCH[1]}))
            elif [[ $line =~ ^FNF:([0-9]+) ]]; then
              FUNCTIONS_FOUND=$((FUNCTIONS_FOUND + ${BASH_REMATCH[1]}))
            elif [[ $line =~ ^FNH:([0-9]+) ]]; then
              FUNCTIONS_HIT=$((FUNCTIONS_HIT + ${BASH_REMATCH[1]}))
            elif [[ $line =~ ^BRF:([0-9]+) ]]; then
              BRANCHES_FOUND=$((BRANCHES_FOUND + ${BASH_REMATCH[1]}))
            elif [[ $line =~ ^BRH:([0-9]+) ]]; then
              BRANCHES_HIT=$((BRANCHES_HIT + ${BASH_REMATCH[1]}))
            fi
          done < ../coverage/lcov.info
          
          # Calculate percentages
          if [ "$LINES_FOUND" -gt 0 ]; then
            LINES_COVERED=$((LINES_HIT * 100 / LINES_FOUND))
          else
            LINES_COVERED=0
          fi
          
          if [ "$FUNCTIONS_FOUND" -gt 0 ]; then
            FUNCTIONS_COVERED=$((FUNCTIONS_HIT * 100 / FUNCTIONS_FOUND))
          else
            FUNCTIONS_COVERED=0
          fi
          
          if [ "$BRANCHES_FOUND" -gt 0 ]; then
            BRANCHES_COVERED=$((BRANCHES_HIT * 100 / BRANCHES_FOUND))
          else
            BRANCHES_COVERED=0
          fi
          
          echo "Lines: $LINES_HIT/$LINES_FOUND ($LINES_COVERED%)"
          echo "Functions: $FUNCTIONS_HIT/$FUNCTIONS_FOUND ($FUNCTIONS_COVERED%)"
          echo "Branches: $BRANCHES_HIT/$BRANCHES_FOUND ($BRANCHES_COVERED%)"
          
          echo "lines_coverage=$LINES_COVERED" >> $GITHUB_OUTPUT
          echo "functions_coverage=$FUNCTIONS_COVERED" >> $GITHUB_OUTPUT
          echo "branches_coverage=$BRANCHES_COVERED" >> $GITHUB_OUTPUT
          echo "coverage_available=true" >> $GITHUB_OUTPUT
          
          # Check if any coverage is below 100%
          if [ "$LINES_COVERED" -lt 100 ] || [ "$FUNCTIONS_COVERED" -lt 100 ] || [ "$BRANCHES_COVERED" -lt 100 ]; then
            echo "coverage_sufficient=false" >> $GITHUB_OUTPUT
            echo "Coverage is insufficient - Lines: $LINES_COVERED%, Functions: $FUNCTIONS_COVERED%, Branches: $BRANCHES_COVERED%"
          else
            echo "coverage_sufficient=true" >> $GITHUB_OUTPUT
            echo "Coverage is sufficient at 100%"
          fi
        else
          echo "‚ùå No lcov.info found in coverage artifact"
          echo "coverage_available=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    # - name: Check for Existing Coverage PR
    #   id: check-existing-pr
    #   run: |
    #     echo "Checking for existing coverage improvement PRs..."
        
    #     # Check if there's already an open PR for coverage improvements
    #     EXISTING_PR=$(gh pr list --state open --search "coverage improvement" --json number --jq '.[0].number' || echo "")
        
    #     if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
    #       echo "existing_pr=$EXISTING_PR" >> $GITHUB_OUTPUT
    #       echo "pr_exists=true" >> $GITHUB_OUTPUT
    #       echo "Found existing PR #$EXISTING_PR"
    #     else
    #       echo "pr_exists=false" >> $GITHUB_OUTPUT
    #       echo "No existing coverage PR found"
    #     fi

    # - name: Create Coverage Improvement Branch
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'false'
    #   run: |
    #     echo "Creating coverage improvement branch..."
        
    #     # Create a new branch for coverage improvements
    #     BRANCH_NAME="coverage-improvement-$(date +%Y%m%d-%H%M%S)"
    #     git checkout -b "$BRANCH_NAME"
    #     echo "branch_name=$BRANCH_NAME" >> $GITHUB_ENV
    #     echo "Created branch: $BRANCH_NAME"

    # - name: Generate Additional Tests
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'false'
    #   working-directory: ./chrome-extension
    #   env:
    #     CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
    #   run: |
    #     echo "Generating additional tests to improve coverage..."
        
    #     # Create a script to analyze uncovered code and generate tests
    #     cat > generate-tests.js << 'EOF'
    #     const fs = require('fs');
    #     const path = require('path');

    #     // Read lcov.info to find uncovered lines
    #     function findUncoveredCode() {
    #       const lcovPath = 'coverage/lcov.info';
    #       if (!fs.existsSync(lcovPath)) {
    #         console.log('No coverage file found');
    #         return [];
    #       }

    #       const lcovContent = fs.readFileSync(lcovPath, 'utf8');
    #       const uncovered = [];
          
    #       let currentFile = '';
    #       const lines = lcovContent.split('\n');
          
    #       for (const line of lines) {
    #         if (line.startsWith('SF:')) {
    #           currentFile = line.substring(3).trim();
    #         } else if (line.startsWith('DA:') && line.includes(',0')) {
    #           const parts = line.substring(3).split(',');
    #           const lineNumber = parseInt(parts[0]);
    #           uncovered.push({
    #             file: currentFile,
    #             line: lineNumber
    #           });
    #         }
    #       }
          
    #       return uncovered;
    #     }

    #     // Generate test suggestions
    #     function generateTestSuggestions(uncovered) {
    #       const suggestions = [];
          
    #       // Group by file
    #       const byFile = {};
    #       uncovered.forEach(item => {
    #         if (!byFile[item.file]) {
    #           byFile[item.file] = [];
    #         }
    #         byFile[item.file].push(item.line);
    #       });

    #       // Generate suggestions for each file
    #       Object.keys(byFile).forEach(file => {
    #         if (file.includes('src/stores/') && file.endsWith('.js')) {
    #           const lines = byFile[file];
    #           suggestions.push({
    #             file: file,
    #             uncoveredLines: lines,
    #             testFile: file.replace('src/stores/', 'src/tests/stores/').replace('.js', '.test.js')
    #           });
    #         }
    #       });

    #       return suggestions;
    #     }

    #     const uncovered = findUncoveredCode();
    #     const suggestions = generateTestSuggestions(uncovered);
        
    #     console.log('Uncovered code found:', uncovered.length, 'lines');
    #     console.log('Suggestions:', suggestions.length, 'files need tests');
        
    #     // Write suggestions to file
    #     fs.writeFileSync('test-suggestions.json', JSON.stringify(suggestions, null, 2));
        
    #     console.log('Test suggestions written to test-suggestions.json');
    #     EOF

    #     # Run the test generation script
    #     node generate-tests.js

    #     # If we have suggestions, use AI to generate actual tests
    #     if [ -f "test-suggestions.json" ] && [ -s "test-suggestions.json" ]; then
    #       echo "Found test suggestions, generating actual tests..."
          
    #       # For each suggestion, generate a test file
    #       cat > generate-actual-tests.js << 'EOF'
    #     const fs = require('fs');
    #     const { execSync } = require('child_process');

    #     const suggestions = JSON.parse(fs.readFileSync('test-suggestions.json', 'utf8'));
        
    #     suggestions.forEach(suggestion => {
    #       const storeFile = suggestion.file;
    #       const testFile = suggestion.testFile;
          
    #       console.log(`Generating tests for ${storeFile}`);
          
    #       // Read the store file to understand what needs testing
    #       if (fs.existsSync(storeFile)) {
    #         const storeContent = fs.readFileSync(storeFile, 'utf8');
            
    #         // Basic test template
    #         const testTemplate = `import { describe, it, expect, vi, beforeEach } from 'vitest';
    #     import { renderHook, act } from '@testing-library/react';
        
    #     // Import the store (adjust import path as needed)
    #     import { use${storeFile.split('/').pop().replace('.js', '')} } from '${storeFile.replace('src/', '../../')}';
        
    #     describe('${storeFile.split('/').pop().replace('.js', '')} Store', () => {
    #       beforeEach(() => {
    #         vi.clearAllMocks();
    #       });
          
    #       // TODO: Add tests for uncovered lines: ${suggestion.uncoveredLines.join(', ')}
    #       it('should handle uncovered functionality', () => {
    #         // This test needs to be implemented based on the uncovered code
    #         expect(true).toBe(true);
    #       });
    #     });`;
            
    #         // Check if test file already exists
    #         if (!fs.existsSync(testFile)) {
    #           fs.writeFileSync(testFile, testTemplate);
    #           console.log(`Created test file: ${testFile}`);
    #         } else {
    #           console.log(`Test file already exists: ${testFile}`);
    #         }
    #       }
    #     });
    #     EOF

    #       node generate-actual-tests.js
    #     fi

    # - name: Run Tests to Verify Coverage Improvement
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'false'
    #   working-directory: ./chrome-extension
    #   run: |
    #     echo "Running tests to verify coverage improvement..."
        
    #     # Run the store tests with coverage
    #     npm run test:stores:coverage
        
    #     # Check if coverage improved
    #     if [ -f "coverage/lcov.info" ]; then
    #       COVERAGE_DATA=$(grep -A 1 "LF:" coverage/lcov.info | tail -n +2 | awk '{print $2}' | tr -d '%')
    #       NEW_LINES_COVERED=$(echo "$COVERAGE_DATA" | head -1)
    #       NEW_FUNCTIONS_COVERED=$(echo "$COVERAGE_DATA" | sed -n '2p')
    #       NEW_BRANCHES_COVERED=$(echo "$COVERAGE_DATA" | sed -n '3p')
          
    #       echo "New coverage: Lines: $NEW_LINES_COVERED%, Functions: $NEW_FUNCTIONS_COVERED%, Branches: $NEW_BRANCHES_COVERED%"
          
    #       # Check if we've reached 100% coverage
    #       if [ "$NEW_LINES_COVERED" -eq 100 ] && [ "$NEW_FUNCTIONS_COVERED" -eq 100 ] && [ "$NEW_BRANCHES_COVERED" -eq 100 ]; then
    #         echo "coverage_improved=true" >> $GITHUB_ENV
    #         echo "coverage_complete=true" >> $GITHUB_ENV
    #       else
    #         echo "coverage_improved=false" >> $GITHUB_ENV
    #         echo "coverage_complete=false" >> $GITHUB_ENV
    #       fi
    #     else
    #       echo "coverage_improved=false" >> $GITHUB_ENV
    #       echo "coverage_complete=false" >> $GITHUB_ENV
    #     fi

    # - name: Commit and Push Changes
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'false'
    #   run: |
    #     echo "Committing and pushing changes..."
        
    #     # Add all changes
    #     git add .
        
    #     # Check if there are changes to commit
    #     if git diff --staged --quiet; then
    #       echo "No changes to commit"
    #       echo "has_changes=false" >> $GITHUB_ENV
    #     else
    #       echo "has_changes=true" >> $GITHUB_ENV
          
    #       # Commit the changes
    #       git commit -m "feat: improve store test coverage

    #       - Added additional tests to increase coverage
    #       - Generated tests for uncovered code paths
    #       - Current coverage: Lines: ${{ steps.coverage-analysis.outputs.lines_coverage }}% ‚Üí ${{ env.NEW_LINES_COVERED || steps.coverage-analysis.outputs.lines_coverage }}%
          
    #       This PR aims to reach 100% test coverage for store tests."
          
    #       # Push the branch
    #       git push origin "${{ env.branch_name }}"
          
    #       echo "Pushed branch: ${{ env.branch_name }}"
    #     fi

    # - name: Create Pull Request
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'false' &&
    #     env.has_changes == 'true'
    #   run: |
    #     echo "Creating pull request for coverage improvements..."
        
    #     # Create the PR
    #     gh pr create \
    #       --title "üöÄ Improve Store Test Coverage to 100%" \
    #       --body "## Coverage Improvement

    #       This PR automatically improves store test coverage to reach 100%.

    #       ### Current Coverage Status
    #       - **Lines**: ${{ steps.coverage-analysis.outputs.lines_coverage }}% ‚Üí ${{ env.NEW_LINES_COVERED || steps.coverage-analysis.outputs.lines_coverage }}%
    #       - **Functions**: ${{ steps.coverage-analysis.outputs.functions_coverage }}% ‚Üí ${{ env.NEW_FUNCTIONS_COVERED || steps.coverage-analysis.outputs.functions_coverage }}%
    #       - **Branches**: ${{ steps.coverage-analysis.outputs.branches_coverage }}% ‚Üí ${{ env.NEW_BRANCHES_COVERED || steps.coverage-analysis.outputs.branches_coverage }}%

    #       ### Changes Made
    #       - Added additional unit tests for uncovered code paths
    #       - Generated tests based on coverage analysis
    #       - Ensured all tests pass before creating this PR

    #       ### Verification
    #       - ‚úÖ All store tests pass
    #       - ‚úÖ Coverage improved
    #       - ‚úÖ No breaking changes

    #       This PR was automatically generated by the Coverage Enforcer workflow." \
    #       --base master \
    #       --head "${{ env.branch_name }}" \
    #       --label "coverage,automated,tests"

    # - name: Comment on Existing PR
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'false' &&
    #     steps.check-existing-pr.outputs.pr_exists == 'true'
    #   run: |
    #     echo "Commenting on existing coverage PR..."
        
    #     # Update existing PR with current coverage status
    #     gh pr comment "${{ steps.check-existing-pr.outputs.existing_pr }}" \
    #       --body "üìä **Coverage Update**

    #       Current store test coverage status:
    #       - **Lines**: ${{ steps.coverage-analysis.outputs.lines_coverage }}%
    #       - **Functions**: ${{ steps.coverage-analysis.outputs.functions_coverage }}%
    #       - **Branches**: ${{ steps.coverage-analysis.outputs.branches_coverage }}%

    #       ‚ö†Ô∏è Coverage is still below 100%. Additional tests may be needed.

    #       _This comment was automatically generated by the Coverage Enforcer workflow._"

    # - name: Success Notification
    #   if: |
    #     steps.coverage-analysis.outputs.coverage_available == 'true' && 
    #     steps.coverage-analysis.outputs.coverage_sufficient == 'true'
    #   run: |
    #     echo "üéâ Store test coverage is at 100%!"
    #     echo "No action needed - all tests are fully covered."

    # - name: Upload Coverage Report
    #   if: always() && steps.coverage-analysis.outputs.coverage_available == 'true'
    #   uses: actions/upload-artifact@v4
    #   with:
    #     name: coverage-analysis-report
    #     path: |
    #       chrome-extension/coverage-report.md
    #       chrome-extension/test-suggestions.json
    #     retention-days: 7
