name: Store Coverage Enforcer

on:
  ## For debug purposes only
  # workflow_dispatch:
  #   inputs:
  #     run-id:
  #       description: 'Workflow run ID to download coverage artifacts from'
  #       required: true
  #       type: string
  workflow_run:
    workflows: [CI Pipeline]
    types: [completed]

permissions:
  contents: write      # Push branches, create commits
  pull-requests: write # Create and manage PRs
  actions: write       # Trigger workflows
  checks: write        # Create/update check runs
  issues: write        # Create issues for tracking

jobs:
  check-coverage:
    if: >-
      ${{ github.event_name == 'workflow_dispatch' || 
          (github.event.workflow_run.conclusion == 'success' && 
           github.event.workflow_run.name == 'CI Pipeline') }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Install GitHub CLI
      if: github.event_name == 'workflow_run'
      run: |
        # Install GitHub CLI
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
        sudo apt update
        sudo apt install gh -y
        
        # Verify installation
        gh --version

    - name: Check if committed files contain src/ folder changes and exit if not
      id: check-src-changes
      run: |
        echo "ðŸ” Checking if this commit contains changes to src/ folder..."
        
        # Get the pull request number from the workflow run (if available)
        PR_NUMBER=$(echo "${{ github.event.workflow_run.pull_requests[0].number }}" || echo "")
        
        if [ -n "$PR_NUMBER" ]; then
          echo "ðŸ“‹ Pull request number: $PR_NUMBER"
          
          # For PRs, get the diff between the PR branch and target branch
          echo "ðŸ“ Fetching changed files in PR #$PR_NUMBER..."
          CHANGED_FILES=$(gh pr diff $PR_NUMBER --name-only 2>/dev/null || echo "")
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸ Could not fetch changed files for PR #$PR_NUMBER"
            echo "This might be due to permissions or PR not found"
            echo "Continuing with workflow execution to be safe..."
            echo "src_changes=true" >> $GITHUB_OUTPUT
          fi
          
          echo "ðŸ“ Changed files in PR #$PR_NUMBER:"
          echo "$CHANGED_FILES"
        else
          echo "âš ï¸ No pull request found for this workflow run"
          echo "This might be a push to main branch or manual trigger"
          echo "Checking committed files using git diff..."
          
          # For pushes or manual triggers, get the diff between commits
          # Get the head commit of the workflow run
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          BASE_SHA="${{ github.event.workflow_run.head_commit.id }}"
          
          # Try to get the previous commit to compare against
          PREV_SHA=$(git rev-parse HEAD~1 2>/dev/null || echo "")
          
          if [ -n "$PREV_SHA" ] && [ "$PREV_SHA" != "0000000000000000000000000000000000000000" ]; then
            echo "ðŸ“ Comparing with previous commit: $PREV_SHA"
            CHANGED_FILES=$(git diff --name-only $PREV_SHA HEAD || echo "")
          else
            echo "ðŸ“ First commit or no previous commit found, checking all files"
            CHANGED_FILES=$(git ls-files || echo "")
          fi
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸ Could not determine changed files"
            echo "Continuing with workflow execution to be safe..."
            echo "src_changes=true" >> $GITHUB_OUTPUT
          fi
          
          echo "ðŸ“ Changed files in this commit:"
          echo "$CHANGED_FILES"
        fi
        
        # Check if any changed file is in the src/ folder (chrome-extension/src/)
        SRC_CHANGES=$(echo "$CHANGED_FILES" | grep -E '^chrome-extension/src/' || echo "")
        
        if [ -n "$SRC_CHANGES" ]; then
          echo "âœ… Found changes in src/ folder:"
          echo "$SRC_CHANGES"
          echo "Continuing with coverage analysis..."
          echo "src_changes=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ No changes found in src/ folder"
          echo "â­ï¸ Coverage Enforcer workflow will be skipped"
          echo "This commit does not contain changes to files in the chrome-extension/src/ folder"
          echo "Only changes to application code trigger coverage analysis"
          echo "Changed files in this commit are likely documentation or configuration files"
          echo "src_changes=false" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure git identity
      if: steps.check-src-changes.outputs.src_changes == 'true'
      run: |
        git config user.name "Coverage Bot"
        git config user.email "coverage-bot@github.com"

    - name: Verify Workflow Run ID
      if: steps.check-src-changes.outputs.src_changes == 'true'
      run: |
        # Determine the workflow run ID based on trigger type
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          RUN_ID="${{ github.event.inputs.run-id }}"
          echo "âœ… Manual trigger - Using provided run ID: $RUN_ID"
        elif [ "${{ github.event_name }}" = "workflow_run" ]; then
          RUN_ID="${{ github.event.workflow_run.id }}"
          echo "âœ… Automatic trigger - Using workflow run ID: $RUN_ID"
        else
          echo "âŒ Unsupported trigger type: ${{ github.event_name }}"
          exit 1
        fi
        
        # Additional fallback logic for workflow_dispatch
        if [ -z "$RUN_ID" ] && [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Try alternative input names
          RUN_ID="${{ github.event.inputs.run_id || github.event.inputs.runId || github.event.inputs.run-id }}"
          echo "ðŸ”„ Trying alternative input names: $RUN_ID"
        fi
        
        if [ -z "$RUN_ID" ]; then
          echo "âŒ Workflow run ID is missing"
          echo "Event name: ${{ github.event_name }}"
          echo "Available inputs: ${{ toJSON(github.event.inputs) }}"
          exit 1
        fi
        
        echo "RUN_ID=$RUN_ID" >> $GITHUB_ENV
        echo "âœ… Workflow run ID set: $RUN_ID"
        
        # Verify environment variables are set correctly
        echo "ðŸ” Environment variables verification:"
        echo "  - RUN_ID env var: '$RUN_ID'"

    - name: Download Coverage Artifacts
      if: steps.check-src-changes.outputs.src_changes == 'true'
      uses: actions/download-artifact@v5
      with:
        name: stores-coverage-report
        path: ./coverage/
        run-id: ${{ env.RUN_ID }}
        repository: ${{ github.repository }}
        github-token: ${{ secrets.GITHUB_TOKEN }}

    - name: Verify Coverage Artifact
      if: steps.check-src-changes.outputs.src_changes == 'true'
      run: |
        echo "ðŸ” Verifying downloaded coverage artifact..."
        echo "=========================================="
        
        # Check if coverage directory exists
        if [ ! -d "./coverage" ]; then
          echo "âŒ Coverage directory not found: ./coverage/"
          echo "This indicates the artifact download failed."
          echo "Please check the previous step for download errors."
          exit 1
        fi
        
        echo "âœ… Coverage directory found: ./coverage/"
        
        # List contents of coverage directory
        echo "ðŸ“ Contents of coverage directory:"
        ls -la ./coverage/
        
        # Check for expected files
        EXPECTED_FILES=(
          "lcov-report/index.html"
          "lcov.info"
          "coverage-final.json"
        )
        
        MISSING_FILES=()
        for file in "${EXPECTED_FILES[@]}"; do
          if [ ! -f "./coverage/$file" ]; then
            MISSING_FILES+=("$file")
          else
            echo "âœ… Found: $file"
          fi
        done
        
        # Check if any critical files are missing
        if [ ${#MISSING_FILES[@]} -gt 0 ]; then
          echo "âš ï¸  Some expected files are missing:"
          for file in "${MISSING_FILES[@]}"; do
            echo "  - $file"
          done
          
          # Check if we have at least the HTML report
          if [ ! -f "./coverage/lcov-report/index.html" ]; then
            echo "âŒ Critical file missing: lcov-report/index.html"
            echo "This file is required for coverage analysis."
            exit 1
          fi
        fi
        
        # Check file sizes to ensure they're not empty
        echo "ðŸ“Š File sizes:"
        find ./coverage -type f -exec ls -lh {} \; | head -10
        
        echo "âœ… Coverage artifact verification completed successfully"
        echo "=========================================="

    - name: Install Node.js
      if: steps.check-src-changes.outputs.src_changes == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: chrome-extension/package-lock.json

    - name: Install Chrome Extension dependencies
      if: steps.check-src-changes.outputs.src_changes == 'true'
      working-directory: ./chrome-extension
      run: npm ci

    - name: Install Coverage Analysis Tools
      if: steps.check-src-changes.outputs.src_changes == 'true'
      run: |
        npm install -g @vitest/coverage-v8
        npm install -g nyc

    - name: Analyze Coverage Data
      if: steps.check-src-changes.outputs.src_changes == 'true'
      id: coverage-analysis
      working-directory: ./chrome-extension
      run: |
        echo "Analyzing coverage data from artifact using Node.js script..."
        
        # Run the Node.js coverage summary script
        # The script will output the coverage results and exit with appropriate code
        if node ../tools/coverage-analyzer/coverage-summary.js ../coverage > coverage-results.env 2>&1; then
          echo "âœ… Coverage analysis completed successfully"
          
          # Source the results from the Node.js script
          # Filter out non-variable lines and source the variables
          grep -E '^[A-Z_]+=' coverage-results.env > coverage-vars.env
          source coverage-vars.env
          
          # Output the results to GitHub Actions step outputs
          echo "lines_coverage=$LINES_COVERED" >> $GITHUB_OUTPUT
          echo "functions_coverage=$FUNCTIONS_COVERED" >> $GITHUB_OUTPUT
          echo "branches_coverage=$BRANCHES_COVERED" >> $GITHUB_OUTPUT
          echo "coverage_available=$COVERAGE_AVAILABLE" >> $GITHUB_OUTPUT
          echo "coverage_sufficient=$COVERAGE_SUFFICIENT" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š Coverage Summary:"
          echo "  Lines: $LINES_COVERED%"
          echo "  Functions: $FUNCTIONS_COVERED%"
          echo "  Branches: $BRANCHES_COVERED%"
          echo "  Available: $COVERAGE_AVAILABLE"
          echo "  Sufficient: $COVERAGE_SUFFICIENT"
        else
          echo "âŒ Coverage analysis failed"
          echo "coverage_available=false" >> $GITHUB_OUTPUT
          echo "coverage_sufficient=false" >> $GITHUB_OUTPUT
          echo "lines_coverage=0" >> $GITHUB_OUTPUT
          echo "functions_coverage=0" >> $GITHUB_OUTPUT
          echo "branches_coverage=0" >> $GITHUB_OUTPUT
          
          # Show the error output for debugging
          echo "Error output:"
          cat coverage-results.env
          exit 1
        fi

    - name: Check Coverage and Exit if 100%
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true'
      run: |
        echo "Checking if test coverage is 100%..."
        
        LINES_COVERED="${{ steps.coverage-analysis.outputs.lines_coverage }}"
        FUNCTIONS_COVERED="${{ steps.coverage-analysis.outputs.functions_coverage }}"
        BRANCHES_COVERED="${{ steps.coverage-analysis.outputs.branches_coverage }}"
        
        echo "Current coverage:"
        echo "  Lines: $LINES_COVERED%"
        echo "  Functions: $FUNCTIONS_COVERED%"
        echo "  Branches: $BRANCHES_COVERED%"
        
        # Check if all coverage metrics are 100%
        if [ "$LINES_COVERED" -eq 100 ] && [ "$FUNCTIONS_COVERED" -eq 100 ] && [ "$BRANCHES_COVERED" -eq 100 ]; then
          echo "ðŸŽ‰ Test coverage is 100%! Exiting pipeline successfully."
          echo "All coverage metrics are at 100% - no further action needed."
          exit 0
        else
          echo "âš ï¸ Test coverage is not 100% - continuing with pipeline..."
          echo "Coverage needs improvement - proceeding with coverage enhancement steps."
        fi

    - name: Create Coverage Improvement Branch
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      run: |
        echo "Creating coverage improvement branch..."
        
        # Create a new branch for coverage improvements
        BRANCH_NAME="coverage-improvement-$(date +%Y%m%d-%H%M%S)"
        git checkout -b "$BRANCH_NAME"
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_ENV
        echo "Created branch: $BRANCH_NAME"

    - name: Analyze Uncovered Code for 100% Coverage
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      working-directory: ./chrome-extension
      run: |
        echo "ðŸ” Analyzing uncovered code to generate natural language summary..."
        
        # Run the coverage analyzer tool
        node ../tools/coverage-analyzer/coverage-analyzer.js

    - name: Install Cursor CLI
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      run: |
        curl https://cursor.com/install -fsS | bash
        echo "$HOME/.cursor/bin" >> $GITHUB_PATH

    - name: Configure git for cursor-agent
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      run: |
        git config user.name "Coverage Bot"
        git config user.email "coverage-bot@github.com"

    - name: Authenticate GitHub CLI
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      run: |
        echo "${{ secrets.GH_TOKEN }}" | gh auth login --with-token
        gh auth status

    - name: Generate Tests for 100% Coverage using Cursor Agent
      if: |
        steps.check-src-changes.outputs.src_changes == 'true' && 
        steps.coverage-analysis.outputs.coverage_available == 'true' && 
        steps.coverage-analysis.outputs.coverage_sufficient == 'false'
      working-directory: ./chrome-extension
      env:
        CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        MODEL: gpt-5
      run: |
        cursor-agent -p "You are operating in a GitHub Actions runner to generate comprehensive stores related test coverage.
        
        The GitHub CLI is available as `gh` and is properly authenticated. Git is available. You have write access to repository contents and can comment on pull requests and create PRs.

        # Context:
        - Current coverage is below 100% and needs improvement
        - You can use "npm run test:stores:coverage" to re-generate coverage report for stores again.
        - Uncovered code analysis has been generated and saved to 'uncovered-analysis.json'
        - Natural language description saved to 'uncovered-description.md'
        - Target: Achieve 100% test coverage for store files

        # Goal:
        Generate comprehensive unit tests for all uncovered code to achieve 100% test coverage.

        # Requirements:
        1) Read the 'uncovered-analysis.json' file to understand what needs testing
        2) For each file with uncovered lines, generate complete test files
        3) Refer to the existing test files for patterns and best practices
        4) Cover ALL uncovered lines mentioned in the analysis
        5) Test every function, method, and code path in the store
        6) Use proper mocking for external dependencies and browser APIs
        7) Test both happy path and edge cases for each uncovered line
        8) Ensure tests are realistic, meaningful, and production-ready
        9) Use existing test patterns from the project
        10) Import statements should be correct relative to test file location
        11) Tests should be well-documented with descriptive names
        12) Focus on achieving 100% line, function, and branch coverage
        13) You are not allowed to create new files, only modify existing ones

        # Output:
        - Modify existing test files for all uncovered code
        - Ensure 100% coverage is achieved
        - Pushed commits to the coverage-improvement branch.
        - Create a draft PR from the coverage-improvement branch to the main branch.
        - Describe what you observed and what you did to improve the coverage in detail in the PR description.
        " --force --model "$MODEL" --output-format=text

