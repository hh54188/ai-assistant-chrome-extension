#!/usr/bin/env node

/**
 * Create Coverage PR Script
 * 
 * This script creates a pull request with the generated tests to improve coverage.
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes for console output
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function makeGitHubRequest(method, path, data) {
  return new Promise((resolve, reject) => {
    const https = require('https');
    const url = require('url');
    
    const parsedUrl = url.parse(`https://api.github.com${path}`);
    const postData = data ? JSON.stringify(data) : null;
    
    const options = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || 443,
      path: parsedUrl.path,
      method: method,
      headers: {
        'Authorization': `token ${process.env.GITHUB_TOKEN}`,
        'User-Agent': 'Store-Coverage-Enforcer',
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      }
    };
    
    if (postData) {
      options.headers['Content-Length'] = Buffer.byteLength(postData);
    }
    
    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          const jsonData = JSON.parse(responseData);
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(jsonData);
          } else {
            reject(new Error(`GitHub API error: ${res.statusCode} - ${jsonData.message || responseData}`));
          }
        } catch (error) {
          reject(new Error(`Failed to parse response: ${error.message}`));
        }
      });
    });
    
    req.on('error', (error) => {
      reject(error);
    });
    
    if (postData) {
      req.write(postData);
    }
    
    req.end();
  });
}

async function createPullRequest() {
  try {
    const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
    const branchName = `coverage-improvement-${Date.now()}`;
    
    // Get current commit SHA
    const currentCommit = process.env.GITHUB_SHA;
    
    // Create new branch
    log(`üìù Creating branch: ${branchName}`, 'blue');
    
    const branchData = {
      ref: `refs/heads/${branchName}`,
      sha: currentCommit
    };
    
    await makeGitHubRequest('POST', `/repos/${owner}/${repo}/git/refs`, branchData);
    log(`‚úÖ Created branch: ${branchName}`, 'green');
    
    // Get coverage analysis
    const coverageAnalysis = JSON.parse(fs.readFileSync('./coverage-analysis.json', 'utf8'));
    
    // Create PR description
    const prDescription = `## Coverage Improvement

This PR automatically improves store test coverage to reach 100%.

### Current Coverage Status
- **Lines**: ${coverageAnalysis.overall.lines.percentage}% (${coverageAnalysis.overall.lines.covered}/${coverageAnalysis.overall.lines.total})
- **Functions**: ${coverageAnalysis.overall.functions.percentage}% (${coverageAnalysis.overall.functions.covered}/${coverageAnalysis.overall.functions.total})
- **Branches**: ${coverageAnalysis.overall.branches.percentage}% (${coverageAnalysis.overall.branches.covered}/${coverageAnalysis.overall.branches.total})

### Changes Made
- Added additional unit tests for uncovered code paths
- Generated tests based on coverage analysis
- Ensured all tests pass before creating this PR

### Files Modified
${coverageAnalysis.uncoveredFiles.map(file => `- ${file.file}`).join('\n')}

### Generated Artifacts
- Coverage analysis report
- Test suggestions
- Generated test files

---
*This PR was automatically generated by the Store Coverage Enforcer workflow.*`;

    // Create pull request
    const prData = {
      title: `Coverage Improvement: ${coverageAnalysis.overall.lines.percentage}% ‚Üí 100%`,
      head: branchName,
      base: 'master',
      body: prDescription
    };
    
    log(`üìù Creating pull request...`, 'blue');
    const pr = await makeGitHubRequest('POST', `/repos/${owner}/${repo}/pulls`, prData);
    
    log(`‚úÖ Created pull request: ${pr.html_url}`, 'green');
    
    // Add labels
    try {
      await makeGitHubRequest('POST', `/repos/${owner}/${repo}/issues/${pr.number}/labels`, {
        labels: ['coverage', 'automated']
      });
      log(`üè∑Ô∏è  Added labels to PR`, 'green');
    } catch (error) {
      log(`‚ö†Ô∏è  Could not add labels: ${error.message}`, 'yellow');
    }
    
    return pr;
    
  } catch (error) {
    log(`‚ùå Error creating pull request: ${error.message}`, 'red');
    throw error;
  }
}

function main() {
  try {
    log('üìù Creating pull request...', 'blue');
    
    if (!process.env.GITHUB_TOKEN) {
      throw new Error('GITHUB_TOKEN environment variable is required');
    }
    
    if (!process.env.GITHUB_REPOSITORY) {
      throw new Error('GITHUB_REPOSITORY environment variable is required');
    }
    
    createPullRequest()
      .then(pr => {
        log(`\nüéâ Pull request created successfully!`, 'green');
        log(`   URL: ${pr.html_url}`, 'cyan');
        log(`   Number: #${pr.number}`, 'cyan');
        
        const outputs = {
          'pr-url': pr.html_url,
          'pr-number': pr.number
        };
        
        const outputsFile = process.env.GITHUB_OUTPUT || '/tmp/github_output';
        const outputContent = Object.entries(outputs)
          .map(([key, value]) => `${key}=${value}`)
          .join('\n');
        fs.writeFileSync(outputsFile, outputContent);
        
        Object.entries(outputs).forEach(([key, value]) => {
          console.log(`::set-output name=${key}::${value}`);
        });
      })
      .catch(error => {
        log(`‚ùå Failed to create pull request: ${error.message}`, 'red');
        process.exit(1);
      });
    
  } catch (error) {
    log(`‚ùå Error: ${error.message}`, 'red');
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = {
  createPullRequest
};